package org.uma.jmetalsp.examples.dynamictsp;import org.uma.jmetal.operator.CrossoverOperator;import org.uma.jmetal.operator.MutationOperator;import org.uma.jmetal.operator.SelectionOperator;import org.uma.jmetal.operator.impl.crossover.PMXCrossover;import org.uma.jmetal.operator.impl.mutation.PermutationSwapMutation;import org.uma.jmetal.operator.impl.selection.BinaryTournamentSelection;import org.uma.jmetal.solution.PermutationSolution;import org.uma.jmetal.util.comparator.RankingAndCrowdingDistanceComparator;import org.uma.jmetalsp.DataConsumer;import org.uma.jmetalsp.DynamicAlgorithm;import org.uma.jmetalsp.DynamicProblem;import org.uma.jmetalsp.JMetalSPApplication;import org.uma.jmetalsp.algorithm.nsgaii.DynamicNSGAIIBuilder;import org.uma.jmetalsp.consumer.ChartConsumer;import org.uma.jmetalsp.consumer.LocalDirectoryOutputConsumer;import org.uma.jmetalsp.impl.DefaultRuntime;import org.uma.jmetalsp.observeddata.AlgorithmObservedData;import org.uma.jmetalsp.observeddata.SingleObservedData;import org.uma.jmetalsp.observer.impl.DefaultObservable;import org.uma.jmetalsp.problem.tsp.MultiobjectiveTSPBuilderFromNYData;import org.uma.jmetalsp.problem.tsp.MultiobjectiveTSPBuilderFromTSPLIBFiles;import org.uma.jmetalsp.problem.tsp.TSPMatrixData;import java.io.IOException;import java.util.List;/** * Example of SparkSP application. * Features: * - Algorithm: to choose among NSGA-II and MOCell * - Problem: Bi-objective TSP * - Default streaming runtime (Spark is not used) * * @author Antonio J. Nebro <antonio@lcc.uma.es> */public class DynamicTSPApplication {  public static void main(String[] args) throws IOException, InterruptedException {	  switch (args.length) {		case 1:			if(args[0].equals("-h")) {				System.out.println("*\n\targ 1 --> fichero de distancias\n" + 						"		 * arg 2 --> fichero de costes\n" + 						"		 * arg 3 --> nombre del fichero con las peticiones\n" + 						"		 * arg 4 --> nombre del directorio que almacena los frentes de pareto\n" + 						"		 * arg 5 --> periodo de lectura de nuevas peticiones en milisegundos(2000)\n"						+ "TODOS LOS FICHEROS DEBEN DE ESTAR EN LA CARPETA jmetal-examples/Datos y solo debe indicar su nombre ");			}			else {				System.out.println("Ejecute la opción -h para ver como se ejecuta el programa");			}			System.exit(-1);			break;		case 5:			;			break;		default:			System.out.println("Ejecute la opción -h para ver como se ejecuta el programa");			System.exit(-1);			break;		}    // STEP 1. Create the problem    DynamicProblem<PermutationSolution<Integer>, SingleObservedData<TSPMatrixData>> problem;    problem = new MultiobjectiveTSPBuilderFromTSPLIBFiles("Datos/" + args[0], "Datos/" + args[1])            .build();    //problem = new MultiobjectiveTSPBuilderFromNYData("data/nyData.txt").build() ;    // STEP 2. Create the algorithm    CrossoverOperator<PermutationSolution<Integer>> crossover;    MutationOperator<PermutationSolution<Integer>> mutation;    SelectionOperator<List<PermutationSolution<Integer>>, PermutationSolution<Integer>> selection;    crossover = new PMXCrossover(0.9);    double mutationProbability = 0.2;    mutation = new PermutationSwapMutation<Integer>(mutationProbability);    selection = new BinaryTournamentSelection<>(            new RankingAndCrowdingDistanceComparator<PermutationSolution<Integer>>());    DynamicAlgorithm<List<PermutationSolution<Integer>>, AlgorithmObservedData<PermutationSolution<Integer>>> algorithm;    algorithm = new DynamicNSGAIIBuilder<>(crossover, mutation, new DefaultObservable<>())            .setMaxEvaluations(25000)            .setPopulationSize(100)            .setSelectionOperator(selection)            .build(problem);    // STEP 3. Create the streaming data source and register the problem    StreamingTSPfromFiles streamingTSPSource = new StreamingTSPfromFiles(new DefaultObservable<>(), Integer.parseInt(args[4]),"Datos/" + args[2]);    streamingTSPSource.getObservable().register(problem);    // STEP 4. Create the data consumers and register into the algorithm    DataConsumer<AlgorithmObservedData<PermutationSolution<Integer>>> localDirectoryOutputConsumer =            new LocalDirectoryOutputConsumer<PermutationSolution<Integer>>(args[3]);    //DataConsumer<AlgorithmObservedData<PermutationSolution<Integer>>> chartConsumer =      //      new ChartConsumer<PermutationSolution<Integer>>(algorithm);    algorithm.getObservable().register(localDirectoryOutputConsumer);    //algorithm.getObservable().register(chartConsumer);    // STEP 5. Create the application and run    JMetalSPApplication<            PermutationSolution<Integer>,            DynamicProblem<PermutationSolution<Integer>, SingleObservedData<Integer>>,            DynamicAlgorithm<List<PermutationSolution<Integer>>, AlgorithmObservedData<PermutationSolution<Integer>>>> application;    application = new JMetalSPApplication<>();    application.setStreamingRuntime(new DefaultRuntime())            .setProblem(problem)            .setAlgorithm(algorithm)            .addStreamingDataSource(streamingTSPSource,problem)            .addAlgorithmDataConsumer(localDirectoryOutputConsumer)            //.addAlgorithmDataConsumer(chartConsumer)            .run();  }}